Sealed 키워드가 JDK 17부터 정식 도입이 됐다. 그러면 이 키워드는 언제 사용해야 하고, 왜 등장했을까? 이 글은 Sealed 키워드가 등장하게 된 배경은 무엇이고, 이 키워드는 어떤 경우에 쓰면 좋을지를 정리하는 글이다.

## 상속의 장점

객체 지향 프로그래밍에서 상속은 코드 재사용과 확장성을 제공하는 핵심 개념입니다. 상속을 통해 우리는:

1. 코드 중복을 줄일 수 있습니다.
2. 기존 클래스를 확장하여 새로운 기능을 추가할 수 있습니다.
3. 다형성을 구현하여 유연한 코드 설계가 가능합니다.

그러나 상속의 무분별한 사용은 클래스 계층 구조를 복잡하게 만들고, 예상치 못한 동작을 야기할 수 있습니다.

## Sealed는 추상화의 이점을 해친다 (양방향 의존 관계)

Sealed 클래스는 상속을 제한함으로써 클래스 계층 구조를 더 엄격하게 관리할 수 있게 해줍니다. 그러나 이는 추상화의 일부 이점을 해칠 수 있습니다:

1. 인터페이스의 본래 목적인 구현 세부사항 은닉이 약화됩니다.
2. 상위 클래스 또는 인터페이스가 하위 클래스에 대해 알게 되어, 양방향 의존 관계가 형성됩니다.
3. 새로운 구현 클래스를 추가할 때마다 상위 인터페이스나 클래스를 수정해야 하므로 유연성이 감소합니다.

이러한 특성으로 인해 Sealed 키워드의 사용은 신중히 고려되어야 합니다.

## 그렇다면 어떤 경우?

Sealed 키워드는 다음과 같은 상황에서 유용하게 사용될 수 있습니다:
1. 도메인 모델링: 특정 도메인 개념의 모든 가능한 변형을 명시적으로 모델링할 때 유용합니다. 예를 들어, 결제 유형이나 주문 상태 등을 표현할 때 사용할 수 있습니다.
   ```java
   public sealed interface PaymentType permits CreditCard, DebitCard, Cash { }
   ```
2. 라이브러리 API 제어: 라이브러리 개발 시 일부 클래스나 인터페이스의 확장을 제한하고 싶을 때 사용합니다. 이는 API의 안정성을 유지하고 의도된 사용만을 허용하는 데 도움이 됩니다.
3. 패턴 매칭 최적화: Java 17부터 도입된 패턴 매칭과 함께 사용할 때, 컴파일러가 모든 가능한 케이스를 알 수 있어 더 효율적인 코드 작성이 가능합니다.
4. 열거형(enum)의 대안: 열거형보다 더 풍부한 기능이 필요하지만, 여전히 제한된 set의 값들을 표현하고 싶을 때 사용할 수 있습니다.
Sealed 클래스는 강력한 도구지만, 그 사용이 코드의 유연성과 확장성을 해치지 않도록 주의해야 합니다. 특히 내부 구현에서는 코드 리뷰, 컨벤션, 문서화 등의 방법으로 불필요한 상속을 제한하는 것이 더 적절할 수 있습니다.

이렇게 적었을 때 대충 4가지 정도의 이점이 있을 수 있는데, 대충 3번은 부가적인 이점인거고, sealed를 통한 도메인 표현력을 늘리는 것도 사실상 IDE를 사용한다면 구현하는 클래스들을 볼 수 있기 떄문에 큰 이점이라고 생각하긴 어렵다.

그래서 내가 생각했을 때 열거형을 클래스처럼 쓰고 싶은 경우나 라이브러리를 개발할 때 내부에서만 사용될 인터페이스가 피치 못하게 외부에 공개되어야 하는 경우, 같은 경우에 사용할 수 있을 것 같다.

결론적으로, Sealed 키워드는 명확한 도메인 모델링이 필요하거나, API 설계 시 의도적인 제한이 필요한 경우에 가장 효과적으로 사용될 수 있습니다.