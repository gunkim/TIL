# JIT(Just In Time) 컴파일러

> JIT 컴파일러는 자바 컴파일러보다 더 다양한 최적화를 할 수 있다.

바이트코드 인터프리터가 가상화한 스택 머신에서 명령어를 실행하며 시작된다. **JIT(Just In Time) 컴파일**은 Runtime에 동적으로 진행되는 컴파일이라고 해서 **동적 컴파일**이라고도 한다.

<img src="../.gitbook/assets/file.excalidraw (1) (1).svg" alt="" class="gitbook-drawing">

**인터프리팅 방식**은 **매번 한줄한줄 해석**해 실행해야 하는데, 이 때 중복된 코드를 매번 해석하는 작업은 **비효율적**이다.

때문에 이러한 비효율적인 작업을 최적화하기 위해 JVM은 **JIT 컴파일러를 활용한다.**

아래는 **JIT 컴파일러**가 최적화해주는 사항들이다.

* **메소드 인라이닝(Method Inlining)** - 복잡하지 않은 메서드라면, 메서드를 제거하고 본문에 포함시켜 호출에 의한 오버헤드를 줄인다.
* **로컬 최적화(Local Optimization)** - 로컬 코드(예를 들어 메서드)를 분석해서 변수의 사용이나 코드 등을 효율화하여 최적화한다.
* **제어 흐름 최적화(Control Flow Optimization)** - 조건문이나 반복문 등 복잡한 코드에서 루프 언롤링(loop-unrolling) 같은 기법을 적용하여 최적화한다.
* **상수 접기(Constant Folding)** - 컴파일 시간에 계산할 수 있는 상수가 있다면, 그 결과를 직접 코드에 적용한다.
* **데드 코드 제거(Dead Code Elimination)** - 메서드를 정의했지만, 호출되지 않는다면 제거한다.
* **전역 최적화(Global Optimization)** - 프로그램 전반에 걸친 변수 사용, 메모리 접근 패턴 등을 분석하여 최적화한다.
* **호출 사이트 최적화(Call Site Optimization)** - 특정 함수에 대한 최적화를 수행한다. 예를 들어 특정 메서드가 항상 같은 값을 반환한다면 그 결과를 캐싱하거나 인라이닝하여 최적화한다.

**JVM의 JIT 컴파일러**는 HotSpot VM처럼 **메소드 단위로 JIT 컴파일** 하는 방식을 사용한다. 이 방식은 더 작은 단위의 [코드 단위 JIT 컴파일(Tracing JIT)](https://en.wikipedia.org/wiki/Tracing\_just-in-time\_compilation) 방식에 전체 코드를 분석하지 않기 때문에 컴파일 속도가 빠르며 메모리 사용량도 적고, 자주 실행되는 메서드를 최적화할 수 있기 때문에 전체 성능을 크게 향상 시키기 유리하다는 장점이 있다.

하지만 캐시 메모리를 많이 사용하며\*\*(대신 페이지 폴트가 적기 때문에 효율적)\*\*, 코드량이 적은 프로그램이라면 JIT 컴파일의 이점을 완전히 활용하지 못할 수 있다는 한계가 존재한다. **(보통 간단한 프로그램은 자바로 짜지 않기 때문에 장점일 수 있다)**

JIT 컴파일러는 Runtime에 자주 실행되는 코드(메서드)를 **핫스팟**으로 지정하고 해당 메서드를 네이티브 코드로 컴파일하여 최적화를 시도하며 여러 최적화 수준이 존재한다.

1. **Cold (차가움) -** 이 레벨은 큰 Java 애플리케이션의 시작 시 사용된다. 목표는 최상의 컴파일 코드 속도를 달성하는 것이며 애플리케이션 초기에는 실행 속도를 최대한 빠르게 만들기 위해 빠른 컴파일이 중요하다.
2. **Warm (따뜻함) -** Java 애플리케이션 시작 후 대부분의 메서드는 호출 임계값에 도달했을 때 컴파일된다. 이는 애플리케이션의 초기 로딩 이후 사용 빈도가 높은 메서드에 초점을 맞추며, 점차적으로 성능을 향상시키는 단계이다.
3. **Hot (뜨거움) -** 1% 이상의 시간을 소비하는 메서드는 Hot 컴파일 대상으로 스케줄링된다. 이러한 메서드는 애플리케이션 성능에 크게 기여하므로, 보다 심층적인 최적화가 이루어진다.
4. **Very Hot (매우 뜨거움) -** **Scorching(타는 듯한)** 레벨은 아니지만 **Hot** 레벨에 속하는 메소드는 매우 뜨거운 컴파일 대상으로 스케줄링된다. 이 레벨은 **Hot**과 **Scorching** 사이의 중간 단계로 볼 수 있으며, 높은 성능 향상을 위한 추가 최적화가 수행된다.
5. **Scorching (타는 듯한) -** 5% 이상의 시간을 소비하는 메소드는 **Scorching** 컴파일 대상으로 스케줄링된다. 이는 애플리케이션 내에서 가장 많은 시간을 소비하는 핵심 메서드들에 대한 최고 수준의 최적화를 의미하며, 이를 통해 애플리케이션의 전반적인 성능을 대폭 향상시킬 수 있다.

기본 최적화 수준은 **Warm(따뜻함)**이며 최적화 수준이 높을수록 성능이 향상되지만 메모리 및 CPU 비용이 증가한다.

이 때 높은 최적화(Hot \~ Scorching) 레벨에서 JVM은 **샘플링(Sampling)**이라고 불리는 스레드를 사용한다. 이 스레드는 실행하는 데 오랜 시간이 걸리는 메소드를 식별한다.

1. **탈출 분석(Escape Analysis)**: 객체가 메소드나 스레드의 범위를 벗어나지 않고 **탈출**하지 않는지 분석한다. 탈출하지 않는 객체는 스택 메모리에 할당될 수 있으며, 이는 힙 메모리 할당보다 효율적이다. 탈출 분석을 통해 가비지 컬렉션에 대한 부담을 줄이고 성능을 향상시킬 수 있다.
2. **부분 중복 제거(Partial Redundancy Elimination, PRE)**: 프로그램 내에서 여러 번 발생하는 계산이나 코드의 중복을 제거한다. 예를 들어, 두 개의 다른 경로를 통해 같은 계산을 수행하는 코드가 있다면, 이 계산을 한 번만 수행하도록 코드를 재구성하여 프로그램의 효율성을 높일 수 있다.
