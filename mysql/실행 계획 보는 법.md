실행 계획이란 SQL을 실행하기 위해 어떤 순서로 어떤 방법으로 처리할지 결정하는 것이며, 이를 볼 때 사용하는 키워드로는 `EXPLAIN`, `DESCRIBE`, `DESC`가 있습니다. 여기서 실행 계획에는 여러 가지항목들이 있는데, 이제 하나씩 살펴보겠습니다.

## select_type

- **SIMPLE**: 가장 기본적인 SELECT 문을 나타내며, 복잡한 서브쿼리나 JOIN이 없는 단순한 SELECT 문입니다.
- **PRIMARY**: UNION, 서브쿼리를 포함한 SELECT 문을 의미합니다. 즉, 서브쿼리나 UNION이 포함된 SELECT 문에서 최상위에 위치한 SELECT 문을 나타냅니다.
- **SUBQUERY**: FROM, WHERE, HAVING 절 안에서 독립적으로 수행되는 서브쿼리를 나타냅니다.
- **DERIVED**: FROM 절 안에서 사용되는 서브쿼리를 의미합니다. 이 경우 서브쿼리가 먼저 실행되고, 결과값이 일시적으로 임시 테이블에 저장된 뒤, 이 임시 테이블에서 SELECT 문이 실행됩니다.
- **UNION**: UNION 구문에서 두 개의 SELECT 문 중 첫 번째 SELECT 문을 나타내며, 이후 두 번째 SELECT 문은 UNION 결과에서 UNION 뒤에 나오게 됩니다.
- **UNION RESULT:** UNION ALL 구문이 아닌 UNION 구문을 사용하여 SELECT 절을 결합한 결과를 의미합니다.
- **DEPENDENT SUBQUERY, DEPENDENT UNION**: 메인 쿼리에 의존하는 서브쿼리나 UNION을 나타냅니다. 이 경우 서브쿼리나 UNION 결과가 메인 쿼리에 영향을 받게 되며, 성능적으로 부담이 될 수 있습니다.
- **UNCACHEABLE SUBQUERY**: 서브쿼리 결과를 메모리에 캐시할 수 없는 경우 발생합니다. 예를 들어, 서브쿼리에서 사용되는 값이 동적으로 변하는 경우에 이 유형이 발생할 수 있습니다.
- **MATERIALIZED**: IN 절에서 사용되는 서브쿼리 결과를 임시 테이블에 저장한 뒤, 이를 조인이나 가공 작업에 사용하는 경우 발생합니다. 이 경우 서브쿼리를 한 번 더 실행해야 하므로 성능상 이슈가 될 수 있습니다.

## table

테이블명 항목은 테이블의 이름과 별칭(alias)을 표시합니다.

## partitions

실행 계획의 부가 정보로, 데이터가 저장된 논리적인 영역을 나타내는 항목입니다.

## type

타입은 테이블 데이터를 어떻게 찾을지에 대한 정보를 제공하는 항목입니다. 전체 테이블을 확인할 것인지, 인덱스를 통해 데이터를 찾을 것인지 등을 결정합니다. 다양한 타입들이 있습니다.

- **system**: 데이터가 없거나 한 개만 있는 테이블의 경우로, 성능상 최상의 타입입니다.
- **const**: 조회되는 데이터가 단 1건일 때 출력되는 유형으로, 성능상 매우 유리한 방식입니다. 고유 인덱스나 기본 키를 사용하여 단 1건의 데이터만 접근하면 되므로 속도나 리소스 사용 측면에서 지향해야 할 타입입니다.
- **eq_ref**: 조인이 수행될 때 드리븐 테이블의 데이터에 접근하며, 고유 인덱스 또는 기본키로 단 1건 데이터를 조회하는 방식입니다. 조인이 수행될 때 성능상 가장 유리한 경우로, 일대일 매핑입니다.
- **ref**: 조인이 수행될 때 드리븐 테이블의 데이터 접근 범위가 2개 이상일 경우 사용됩니다. 드라이빙 테이블과 드리븐 테이블이 조인을 수행하면 일대다 관계가 되므로, 드라이빙 테이블의 1개 값이 드리븐 테이블에서는 2개 이상의 데이터로 존재합니다. 이 때 기본키나 고유 인덱스를 활용하면 2개 이상의 데이터가 검색되거나 유일성이 없는 비고유 인덱스를 사용하게 됩니다. 드리븐 테이블의 데이터 양이 많지 않을 때는 성능 저하를 크게 우려하지 않아도 되지만, 데이터 양이 많다면 접근해야 할 데이터 범위가 넓어져 성능 저하의 원인이 되는지 확인해야 합니다. 한편으로 =, <, > 등 연산자를 사용해 인덱스로 생성된 열을 비교할 때도 출력됩니다.
- **ref_or_null**: is null 구문에 대해 인덱스를 활용하도록 최적화된 방식입니다. MySQL, MariaDB는 null에 대해 인덱스를 활용해 검색할 수 있으며 이 때 Null은 가장 앞쪽에 정렬됩니다. 테이블에서 검색할 Null 데이터양이 적다면 ref_or_null 방식을 활용했을 때 효율적인 SQL문이 될 것이나, 검색할 Null 데이터 양이 많다면 SQL 튜닝 대상이 될 것입니다.
- **range**: 테이블 내 연속된 데이터 범위를 조회하는 유형으로, =, <>, >, ≥, <, ≤, is null, ≤>, between, in 연산을 통해 범위 스캔을 수행하는 방식입니다. 주어진 데이터 범위 내에서 행 단위로 스캔하지만 스캔 범위가 넓으면 성능 저하 요인이 될 수 있습니다. 튜닝 검토 대상입니다.
- **fulltext**: 텍스트 검색을 빠르게 처리하기 위해 전문 인덱스를 사용하여 데이터에 접근하는 방식입니다.
- **index_merge**: 결합된 인덱스들이 동시에 사용되는 유형으로, 특정 테이블에 생성된 두 개 이상의 인덱스가 병합되어 동시에 적용됩니다. 이 때 전문 인덱스는 제외됩니다.
- **index**: 인덱스 풀스캔을 의미합니다. 물리적인 인덱스 블록을 처음부터 끝까지 훑는 방식입니다.
- **ALL**: 테이블을 처음부터 끝까지 읽는 테이블 풀 스캔 방식에 해당됩니다. 활용할 수 있는 인덱스가 없거나 인덱스를 활용하는 것이 오히려 비효율적이라고 옵티마이저가 판단했을 때 선택됩니다. 전체 테이블 중 10~20% 이상 분량의 데이터를 조회할 때는 ALL 유형이 오히려 성능상 유리할 수 있습니다.

## possible_keys

옵티마이저가 SQL문을 최적화하기 위해 사용할 수 있는 인덱스 목록을 출력합니다. 하지만 실제 사용한 인덱스가 아닌 사용할 수 있는 후보군의 기본 키와 인덱스 목록만 보여주므로, SQL 튜닝에 직접적인 효용성은 없습니다.

## key

옵티마이저가 SQL문을 최적화하기 위해 사용한 기본 키 또는 인덱스명을 의미합니다. 어떤 인덱스로 데이터를 검색했는지 확인할 수 있으므로, 비효율적인 인덱스를 사용했거나 인덱스 자체를 사용하지 않았다면 SQL 튜닝 대상이 됩니다.

## key_len

인덱스를 사용할 때는 인덱스 전체를 사용하거나 일부 인덱스만 사용합니다. key_len은 사용한 인덱스의 바이트 수를 의미합니다. UTF-8 캐릭터셋 기준으로, INT 데이터 유형은 단위당 4바이트로, VARCHAR 데이터 유형은 단위당 3바이트임을 인지하고 이해해야 합니다.

## ref

ref는 reference의 약자로, 테이블 조인을 수행할 때 어떤 조건으로 해당 테이블에 액세스되었는지 알려주는 정보입니다.

## rows

rows는 SQL문을 수행하기 위해 접근하는 데이터의 모든 행 수를 나타내는 예측 항목입니다. 즉, 디스크에서 데이터 파일을 읽고 메모리에서 처리해야 할 행 수를 예상하는 값입니다. 이 값은 수시로 변동되는 MySQL 통계 정보를 참고하여 산출되므로, 수치가 정확하지 않습니다. 또한 최종 출력될 행 수가 아니라는 점에 유의해야 합니다. 그러나 최종 SQL문의 결과 수와 큰 차이가 날 때는 불필요하게 MySQL 엔진까지 데이터를 많이 가져왔다는 뜻이므로, SQL 튜닝 대상이 될 수 있습니다.

## filtered

filtered는 SQL문을 통해 DB 엔진으로 가져온 데이터 대상으로 필터 조건에 따라 어느 정도 비율로 데이터를 제거했는지 의미하는 항목입니다. 예를 들어, DB 엔진으로 100건의 데이터를 가져왔다고 가정했을 때, WHERE 절의 사원번호 between 1 and 10 조건으로 100건의 데이터가 10건으로 필터링된다면, 이 때 100건에서 10건으로 필터링됐으므로, 10이라는 정보가 출력될 것입니다. 단위는 %입니다.

filtered 값은 SQL문을 실행한 후 얼마나 많은 데이터가 필터링되었는지 확인할 수 있어서, 필터링 과정에서 성능 저하가 발생하는지 판단하는 데 도움이 됩니다. 필터링 과정에서 큰 비율의 데이터가 제거된다면, 이는 SQL문의 조건이 너무 많은 데이터를 가져온 후에 필터링을 수행하고 있다는 것을 의미하므로, SQL 튜닝 대상이 될 수 있습니다.

## extra

SQL문을 어떻게 수행할 것인지에 관한 추가 정보를 보여주는 항목입니다. 이러한 부가 정보들은 세미콜론으로 구분하여 여러 가지 정보들을 나열할 수 있으며, 이 정보들은 다음과 같은 항목으로 정리할 수 있습니다.

- **Distinct:** 중복이 제거되어 유일한 값을 찾을 때 출력되는 정보입니다. 이 때 DISTINCT 키워드 혹은 UNION 구문이 포함된 경우 출력됩니다. DISTINCT는 선택된 컬럼 값의 중복을 제거하고 유니크한 값을 반환합니다. 이를 통해 결과셋의 크기를 줄일 수 있습니다.
- **Using where**: 실행 계획에서 자주 볼 수 있는 extra 정보입니다. WHERE 절의 필터 조건을 사용해 MySQL 엔진으로 가져온 데이터를 추출할 것이라는 의미로 이해할 수 있습니다. 이 정보는 쿼리가 어떻게 실행되는지 이해하는 데 도움이 됩니다.
- **Using temporary**: 데이터 중간 결과를 저장하고자 임시 테이블을 생성하겠다는 의미입니다. 데이터를 가져와 저장한 뒤 정렬 작업을 수행하거나 중복을 제거하는 작업 등을 수행합니다. 보통 DISTINCT, GROUP BY, ORDER BY 구문이 포함된 경우 Using temporary 정보가 출력됩니다.
- **Using index**: 물리적인 데이터 파일을 읽지 않고 인덱스만을 읽어서 SQL문의 요청사항을 처리할 수 있는 경우입니다. 이를 커버링 인덱스 방식이라고 부르며, 인덱스로 구성된 열만 SQL 문에서 사용할 경우 이 방식을 활용합니다. 물리적으로도 테이블보다 인덱스가 작고 정렬되어 있으므로 적은 양의 데이터에 접근할 때 성능 측면에서 효율적입니다.
- **Using filesort**: 정렬이 필요한 데이터를 메모리에 올리고 정렬 작업을 수행한다는 의미입니다. 보통 이미 정렬된 인덱스를 사용하면 추가 정렬 작업이 필요 없지만, 인덱스를 사용하지 못할 때는 정렬을 위해 메모리 영역에 데이터를 올리게 됩니다. 추가 정렬 작업이므로 인덱스를 활용하도록 SQL 튜닝 검토 대상이 될 수 있습니다.
- **Using join buffer**: 조인을 수행하기 위해 중간 데이터 결과를 저장하는 조인 버퍼를 사용한다는 의미입니다. 즉, 드라이빙 테이블의 데이터에 먼저 접근한 결과를 조인 버퍼에 담은 뒤, 조인 버퍼와 드리븐 테이블 간에 서로 일치하는 조인 키 값을 찾는 과정을 수행합니다. 조인 버퍼를 효율적으로 사용하면 성능 향상을 이룰 수 있습니다.
- **Using union / Using intersect / Using sort_union**: 앞서 실행 계획 type 항목에서 두 개 이상의 인덱스가 병합되어 데이터에 접근하는 경우를 나타내는 index_merge를 설명했습니다. 이처럼 인덱스가 병합되어 실행되는 SQL문의 extra 항목에는 인덱스를 어떻게 병합했는지에 관한 상세 정보가 출력됩니다. 그게 이 정보입니다.
    - **Using Union**: 인덱스들을 합집합처럼 모두 결합하여 데이터에 접근한다는 뜻입니다. 보통 SQL문이 OR 구문으로 작성된 경우에 해당합니다.
    - **Using intersect**: 인덱스들을 교집합처럼 추출하는 방식입니다. SQL문이 AND 구문으로 작성된 경우에 확인할 수 있는 extra 정보입니다.
    - **Using sort_union**: 기본적으로 Using union과 유사하지만, WHERE 절의 OR 구문이 동등 조건이 아닐 때 확인할 수 있는 extra 정보입니다.
- **Using index condition**: MySQL 엔진에서 인덱스로 생성된 열의 필터 조건에 따라 요청된 데이터만 필터링하는 Using where 방식과 달리, 필터 조건을 스토리지 엔진으로 전달하여 필터링 작업에 대한 MySQL 엔진의 부하를 줄이는 방식으로 이해하면 됩니다. 이는 스토리지 엔진의 데이터 결과를 MySQL 엔진으로 전송하는 데이터 양을 줄여 성능 효율을 높일 수 있는 옵티마이저 최적화 방식입니다.
- **Using index condition(BKA)**: type 정보의 Using index condition 유형과 비슷하나, 데이터를 검색하기 위해 배치 키 액세스를 사용하는 방식입니다. 이 방식은 조인 연산에서 성능을 향상시킬 수 있습니다.
- **Using index for group-by**: SQL 문에 GROUP BY 구문이나 DISTINCT 구문이 포함될 때는 인덱스로 정렬 작업을 수행하여 최적화합니다. 이 때 인덱스로 정렬 작업을 수행하는 인덱스 루스 스캔일 때 출력되는 부가 정보입니다.
- **Not exists**: 하나의 일치하는 행을 찾으면 추가로 행을 더 검색하지 않아도 될 때 출력되는 유형입니다. 왼쪽 외부 조인 또는 오른쪽 외부 조인에서 테이블에 존재하지 않는 데이터를 명시적으로 검색할 때 발생합니다. Not exists 절은 결과에서 존재하지 않는 행을 필터링하는 데 사용됩니다. 이 절은 서브쿼리를 포함하여 사용되며, 일반적으로 왼쪽 테이블에 있는 행이 오른쪽 테이블과 일치하는 행이 없는 경우에만 결과에 포함되도록 합니다.

## 참고
- 업무에 바로 쓰는 SQL 튜닝