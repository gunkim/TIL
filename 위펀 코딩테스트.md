## 1번 문제
### 문제 설명
매달 k 일은 아파트 관리비를 내는 날입니다. 만약 그달의 K 일이 주말(토요일, 일요일)이라면 관리비는 k 일로부터 가장 가까운 평일에 냅니다. 한 해의 시작일인 1월 1일에 해당하는 요일 day 와 매달 관리비를 내야 하는 날짜 k가 매개변수로 주어질 때, 그해의 1월부터 12월까지 매달 k 일이 평일이면 0을, 주말이면 1을 순서대로 배열에 담아 return 하도록 Solution 함수를 완성해 주세요.
### 제한사항
- ﻿﻿1월 1일에 해당하는 요일은 다음과 같이 숫자로 주어집니다.
- ﻿﻿월요일: 0, 화요일: 1, 수요일: 2, 목요일: 3, 금요일: 4, 토요일: 5, 일요일: 6
- ﻿k는 1 이상 28 이하의 자연수입니다.
- ﻿﻿각 달의 날짜 수는 1월부터 순서대로 [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31] 이 며, 윤년과 공휴일은 고려하지 않습니다.
### 입출력 예

| day | k   | result                   |
| --- | --- | ------------------------ |
| 6   | 1   | [1,0,0,1,0,0,1,0,0,1,0,0 |
| 6   | 25  | [0,11,0,0,1,0,0,0,0,1,0] |

#### 입출력 예 #1
이 예시에서 1월 1일은 일요일이고, 매달 1일에 관리비를 내야 합니다. 1월 1일은 주말이므로 result 배열의 첫 번째 원소는 1입니다. 2월부터 12월까지 매달 1일에 해당하는 요일은 다음과 같습니다.
- ﻿﻿2월: 수요일
- ﻿﻿3월: 수요일
- ﻿﻿4월: 토요일
- ﻿﻿5월: 월요일
- ﻿﻿6월: 목요일
- ﻿﻿7월: 토요일
- ﻿﻿8월: 화요일
- ﻿﻿9월: 금요일
- ﻿﻿10월: 일요일
- ﻿﻿11월: 수요일
- ﻿﻿12월: 금요일
따라서 1월부터 순서대로 [1,0,0,1,0,0,1,0,0,1,0,0]을 return 하면 됩니다.
#### 입출력 예 #2
이 예시에서 1월 1일은 일요일이고, 매달 25일에 관리비를 내야 합니다. 1월 25일은 수요일이므 로 result 배열의 첫 번째 원소는 0입니다. 마찬가지로 2월~12월까지 매달 25일에 해당하는 요 일은 2월부터 순서대로 토요일, 토요일, 화요일, 목요일, 일요일, 화요일, 금요일, 월요일, 수요 일, 토요일, 월요일입니다. 따라서 1월부터 순서대로 [0,1,1,0,0,1,0,0,0,0,1,0]을 return 하면 됩 니다.
### 제출
```java
class Solution {
	public int[] solution(int day, int k) {
		int[] daysInMonth = {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};
		int[] result = new int[12];

		for (int i = 0; i < 12; i++) {
			int dayOfMonth = (day + (k - 1)) % 7;
			
			if (dayOfMonth == 5 || dayOfMonth == 6) {
				result[i] = 1;
			} else {
				result[i] = 0;
			}
			day = (day + daysInMonth[i]) % 7;
		} 
		return result;
	}
}
```
## 2번 문제
### 문제 설명
유저가 주문한 음식 데이터를 이용해 음식을 가장 다양하게 주문한 유저는 누구인지 알아보려 합니다. 유저는 주문 한 번당 음식 여러 종류를 주문하며, 같은 음식을 여러 번 주문할 수도 있습 니다.

예를 들어 음식 주문 데이터가 다음과 같은 경우
["alex pizza pasta", "alex pizza pizza", "alex noodle", "bob pasta", "bob noodle sandwich pasta", "bob steak noodle"]
- ﻿"alex"는 "pizza", "pasta", "noodle"을 주문했습니다.
- ﻿﻿"bob"은 "pasta", "noodle", "sandwich", steak"를 주문했습니다.
따라서 "bob"이 주문한 음식이 총 네 종류로 가장 많습니다.

유저 ID와 각 유저가 주문한 음식이 문자열 형태로 들어있는 배열 orders가 매개변수로 주어질 때, 가장 많은 종류의 음식을 주문한 유저의 아이디를 배열에 담아 return 하도록 solution 함수 를 완성해주세요. 만약, 그런 유저가 여러 명이면 해당 유저들을 오름차순으로 정렬해 return 하 면 됩니다.
### 제한사항
- ﻿﻿1 <= orders의 길이 <= 200,000
- ﻿﻿orders의 원소는 음식 주문 데이터가 "유저ID 음식1 음식2 .." 순서로 들어있습니다.
- ﻿﻿유저는 한 번에 최대 5개까지 음식을 주문합니다.
- ﻿﻿유저 ID와 음식 이름은 공백(스페이스 바) 하나로 구분해서 주어집니다.
- ﻿﻿음식과 음식도 공백(스페이스 바) 하나로 구분해서 주어집니다.
- ﻿﻿유저 ID와 음식 이름은 길이가 1 이상 10 이하인 문자열이며, 알파벳 소문자로만 이 루어져 있습니다.
### 입출력 예
| orders                                                                                                                       | result   |
| ---------------------------------------------------------------------------------------------------------------------------- | -------- |
| ["alex pizza pasta", "alex pizza pizza", "alex noodle", "bob pasta",<br><br>"bob noodle sandwich pasta", "bob steak noodle"] | ["bob"]  |
| ["alex pizza pasta steak", "bob noodle sandwich pasta", "choi pizza                                                          | ["alex", |
| sandwich pizza", "alex pizza pasta steak"]                                                                                   | "bob"]   |

#### 입출력 예 #1
문제 예시와 같습니다.
#### 입출력 예#2
"alex"와 "bob"은 음식 세 종류를 주문했으며, "choi"는 두 종류를 주문했습니다. 따라서 오름 차순 정렬하여 ["alex", "bob"]을 return하면 됩니다.
### 제출
```java
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

class Solution {
	public String[] solution(String[] orders) {
		Map<String, Set<String>> userFoodMap = new HashMap<>();
  
		for (String order : orders) {
			String[] parts = order.split(" ");
			String userId = parts[0];
			
			userFoodMap.putIfAbsent(userId, new HashSet<>());

			for (int i = 1; i < parts.length; i++) {
				userFoodMap.get(userId).add(parts[i]);
			}
		}  
		int maxVariety = 0;
		
		for (Set<String> foods : userFoodMap.values()) {
			maxVariety = Math.max(maxVariety, foods.size());
		}

		List<String> result = new ArrayList<>();
		for (Map.Entry<String, Set<String>> entry : userFoodMap.entrySet()) {
			if (entry.getValue().size() == maxVariety) {
				result.add(entry.getKey());
			}
		}

		Collections.sort(result);

		return result.toArray(new String[0]);
	}
}
```
## 3번 문제
### 문제 설명
보험 항목별 보장 금액이 순서대로 들어있는 배열이 있습니다. 주어진 항목 중에서 k개 이상의 항목을 선택하여 새 보 험 상품을 만들되, 새 보험 상품에 포함되는 각 항목의 보장 금액의 함이 t 이하가 되도록 하려고 합니다. 다음은 항목 별 보장 금액이 들어있는 배열 [2, 5, 3, 8, 1], k= 3, t= 11 이 주어진 경우의 예시입니다.

먼저 주어진 배열은 5개의 보험 항목의 보장 금액이 순서대로 [2, 5, 3, 8, 17임을 나타냅니다. 이때, 3개 이상의 항목 을 선택하는 방법은 총 16가지가 있는데, 이 중, 선택된 항목들의 보장 금액의 합이 11 이하가 되는 경우는 다음과 같이

6가지가 있습니다.

- ﻿﻿[2, 5, 3]
- ﻿﻿[2,5,1
- ﻿﻿[5,3,1]
- ﻿﻿[2,3,1
- ﻿﻿[2, 8, 1]
- ﻿﻿[2, 5, 3, 1]

예를 들어 선택한 항목의 보장 금액이 [2, 5, 3, 1] 인 경우 보장 금액의 합은 2+ 5+ 3+ 1 = 11이므로 11 이하가 됩 니다. 그러나 만약 선택한 항목의 보장 금액이 [5, 3, 81인 경우 보장 금액의 합은 5+ 3+ 8 = 16이므로 이 경우는 불 가능한 방법이 됩니다.

항목별 보장 금액이 순서대로 들어있는 배열 arr와 k, t가 매개변수로 주어질 때, arr에서 k개 이상의 항목을 선택했을 때, 금액 합이 t 이하가 되도록 하는 경우의 수를 return 하도록 solution 함수를 완성해주세요.
### 제한사항
- ﻿﻿arr는 각 보험 항목별 보장 금액이 순서대로 들어있는 배열이며, 길이는 1 이상 15 이하입니다.
- ﻿﻿ar의 각 원소는 1 이상 100,000 이하의 자연수입니다.
- ﻿﻿k는 1 이상 15 이하의 자연수이며, 항상 arr 의 길이 이하인 경우만 주어집니다.
- ﻿﻿t는 1 이상 1,000,000 이하의 자연수입니다.
### 입출력 예

| arr         | k   | t   | result |
| ----------- | --- | --- | ------ |
| [2,5,3,8,1] | 3   | 11  | 6      |
| [1,1,2,2]   | 2   | 3   | 5      |
| [1,2,3,2]   | 2   | 2   | 0      |

#### 입출력 예 #1
문제의 예시와 같습니다.
#### 입출력 예#2
다음과 같이 5가지 경우가 가능합니다.
- ﻿﻿[1, 1], (첫 번째, 두 번째 항목)
- ﻿[1, 2], (첫 번째, 세 번째 항목)
- ﻿﻿[1, 2], (첫 번째, 네 번째 항목)
- ﻿﻿[1, 2], (두 번째, 세 번째 항목)
- ﻿﻿[1, 2], (두 번째, 네 번째 항목)
#### 입출력 예 #3
2가지 이상을 선택하면서 금액 합계가 2 이하가 되도록 하는 방법은 없습니다.
### 제출
```java
class Solution {
	public int solution(int[] arr, int k, int t) {
		return countValidCombinations(arr, k, t, 0, 0, 0);
	}
	private int countValidCombinations(int[] arr, int k, int t, int index, int selectedCount, int currentSum) {
		if (currentSum > t) return 0;
		
		if (index == arr.length) {
			return selectedCount >= k ? 1 : 0;
		}

		int include = countValidCombinations(arr, k, t, index + 1, selectedCount + 1, currentSum + arr[index]);

		int exclude = countValidCombinations(arr, k, t, index + 1, selectedCount, currentSum);

		return include + exclude;
	}
}
```
## 4번 문제
### 문제 설명
숲속에 토끼가 살고 있습니다. 겁이 많은 토끼는 맹수의 습격을 피하기 위해 안전한 토끼굴로 도망치려고 합니다. 토끼 와 토끼굴은 다음 그림과 같이 수직선 위에 표현할 수 있는데, 토끼는 항상 0의 위치에 있으며, 토끼굴은 n 만큼 떨어 진 위치에 있습니다. 다음은 n = 9 인 경우의 예시입니다.

토끼는 수직선 위에서 움직이며, 항상 자연수 거리만큼 점프합니다. 또, 처음 점프한 방향으로만 계속해서 점프할 수 있습니다(즉, 방향을 바꿀 수 없습니다). 토끼는 처음 점프할 때는 어떤 거리든지 점프할 수 있는데, 첫 점프 이후에는 힘이 조금씩 빠지기 때문에 항상 이전에 점프 한 거리보다 짧게 점프합니다. 이때 토끼가 토끼굴에 k 번 점프해서 도착 하는 방법의 가짓수를 구하려 합니다. 예를 들어 위 그림에서 토끼는 0의 위치에 있으며 토끼굴은 9 만큼 떨어진 위치 에 있습니다. 이때, k= 3이라면, 토끼가 3번 점프해서 토끼굴에 도착하는 방법은 다음과 같이 세 가지가 있습니다.
- ﻿﻿처음에 6만큼 점프 후 다음에 2만큼 점프하고 마지막에 1만큼 점프합니다.
- ﻿﻿처음에 5만큼 점프 후 다음에 3만큼 점프하고 마지막에 1만큼 점프합니다.
- ﻿﻿처음에 4만큼 점프 후 다음에 3만큼 점프하고 마지막에 2만큼 점프합니다.

토끼굴의 위치 n과 토끼의 점프 횟수 k가 매개변수로 주어질 때, 토끼가 k 번 점프해서 토끼굴에 도착하는 방법의 가짓 수를 return 하도록 solution 함수를 완성해주세요. 단, 답이 커질 수 있으므로 정답을 1,000,000,007로 나눈 나머지 를 return해주세요.
### 제한사항
- ﻿﻿n은 토끼굴의 위치를 나타내며, 1 이상 300 이하의 자연수입니다.
- ﻿﻿k는 토끼가 점프하는 횟수를 나타내며, 1 이상 24 이하의 자연수입니다.
- ﻿﻿정답을 1,000,000,007로 나눈 나머지를 return해주세요
### 입출력 예

| n   | k   | result |
| --- | --- | ------ |
| 9   | 3   | 3      |
| 10  | 2   | 4      |
| 9   | 4   | 0      |

#### 입출력 예 #1
문제의 예시와 같습니다.
#### 입출력 예#2
다음과 같이 4가지가 가능합니다.
- ﻿﻿처음에 9만큼 점프한 후 1만큼 점프합니다.
- ﻿﻿처음에 8만큼 점프한 후 2만큼 점프합니다.
- ﻿﻿처음에 7만큼 점프한 후 3만큼 점프합니다.
- ﻿﻿처음에 6만큼 점프한 후 4만큼 점프합니다.
처음에 5만큼 점프 한다면, 그 후에는 반드시 5보다 적게 점프해야 하므로 두 번 만에 10 위치에 도달할 수 없습니다.
따라서 가능한 방법은 4가지입니다.

#### 입출력 예 #3
토끼가 네 번 점프해서 9 위치에 도착하는 방법은 없습니다.
### 제출
```java
class Solution {
	public int solution(int n, int k) {
		final int MOD = 1_000_000_007;

		long[][][] dp = new long[k + 1][n + 1][n + 1];

		for (int j = 1; j <= n; j++) {
			dp[1][j][j] = 1;
		}

		for (int i = 2; i <= k; i++) {
			for (int j = i; j <= n; j++) {
				for (int l = 1; l < j; l++) {
					for (int prev = l + 1; prev <= j - l; prev++) {
						dp[i][j][l] = (dp[i][j][l] + dp[i-1][j-l][prev]) % MOD;
					}
				}
			}
		}  

		long answer = 0;
		
		for (int l = 1; l <= n; l++) {
			answer = (answer + dp[k][n][l]) % MOD;
		}

		return (int) answer;
	}
}
```
## 5번 문제
### 문제 설명
GAME_USERS 테이블은 XX런 게임 유저의 정보를 담고 있는 테이블입니다. GAME_USERS 테이블 구조는 다음과 같으며, ID, DISTANCE, TIME_SPENT, BEST_DATE는 각각 유저의 아이디, 최고 기록(미터 단위), 게임을 한 시 간, 최고기록 경신 날짜를 나타냅니다.

| NAME       | TYPE     |
| ---------- | -------- |
| ID         | VARCHAR  |
| DISTANCE   | INT      |
| TIME_SPENT | DECIMAL  |
| BEST_DATE  | DATETIME |

CHARACTERS 테이블은 XX런게임에서 살 수 있는 캐릭터의 정보를 담고 있는 테이블입니다. CHARACTERS 테이블 구조는 다음과 같으며, MAME, SPEED, BOOST_SPEED, BOOST_TIME, PRICE 는 각각 캐릭터의 이름, 속도, 부스트 속도, 부스트 지속 시간, 가격을 나타냅니다.

| NAME        | TYPE    |
| ----------- | ------- |
| NAME        | VARCHAR |
| SPEED       | INT     |
| BOOST_SPEED | INT     |
| BOOST_TIME  | INT     |
| PRICE       | INT     |

PURCHASES 테이블은 XX런 게임의 유료캐릭터 구매내역을 담고 있는 테이블입니다. PURCHASES 테이블의 구조는 다음과 같으며, ID, USER_ID, PURCHASE_DATE, ITEN은 각각 ID, 유저의 ID, 구매 날짜, 산 캐릭터의 이름을 나타냅니다.

| NAME          | TYPE     |
| ------------- | -------- |
| ID            | INT      |
| USER_ID       | VARCHAR  |
| PURCHASE_DATE | DATETIME |
| ITEM          | VARCHAR  |
### 문제
GAME_USERS 테이블에 있는 모든 유저에 대해, 유저의 id와 유저가 구입한 유료 캐릭터 수, 유저의 총 구입액을 조회 하는 SQL 문을 작성하세요. 결과는 유저의 id 순으로 조회되어야 하며, 캐릭터를 한 번도 사지 않은 유저의 총 구입액 은 0입니다.

예시

예를 들어, GAME_ USERS 테이블, CHARACTERS 테이블, PURCHASES 테이블이 다음과 같다면

GAME_USERS

| ID    | DISTANCE | TIME SPENT  | BEST _DATE          |
| ----- | -------- | ----------- | ------------------- |
| user1 | 59600    | 5.632400104 | 2016-11-19 21:47:30 |
| user2 | 79900    | 2.639340620 | 2016-12-19 13:59:55 |
| user3 | 99000    | 4376248407  | 2016-12-09 14:18:32 |

CHARACTERS

| NAME      | SPEED | BOOST_SPEED | BOOST-TIME | PRICE |
| --------- | ----- | ----------- | ---------- | ----- |
| Albatross | 198   | 447         | 12         | 1000  |
| Bee       | 201   | 472         | 7          | 3000  |

PURCHASES

| ID  | USER_ID | PURCHASE DATE       | ITEM      |
| --- | ------- | ------------------- | --------- |
| 1   | user1   | 2016-12-16 07:44:17 | Albatross |
| 2   | user2   | 2016-12-1110:30:05  | Albatross |
| 3   | user1   | 2016-11-16 23:23:32 | Bee       |

- user1은 캐릭터 Albatross와 Bee를 샀으며, 구입액은 4000입니다.
- user2는 캐릭터 Albatross를 샀으며, 구입액은 1000입니다.
- user3은 아무것도 사지 않았으므로, 구입액은 0입니다.
따라서 이때는 SQL을 실행하면 다음과 같이 출력되어야 합니다.

| USER_ID | PURCHASE_COUNT | TOTAL PRICE |
| ------- | -------------- | ----------- |
| user1   | 2              | 4000        |
| user2   | 1              | 1000        |
| user3   | 0              | 0           |
### 제출
```sql
SELECT
	g.ID AS USER_ID,
	COUNT(p.ID) AS PURCHASE_COUNT,
	IFNULL(SUM(c.PRICE), 0) AS TOTAL_PRICE
FROM
	GAME_USERS g
	LEFT JOIN
	PURCHASES p ON g.ID = p.USER_ID
	LEFT JOIN
	CHARACTERS c ON p.ITEM = c.NAME
GROUP BY
	g.ID
ORDER BY
	g.ID
;
```
## 6번 문제
### 문제 설명
PLACES 테이블은 공간 임대 서비스에 등록된 공간의 정보를 담은 테이블입니다. PLACES 테이블의 구조는 다음과 같으며 ID, NAME , HOST_ID는 각각 공간의 아이디, 이름, 공간을 소유한 유저의 아이디를 나타냅니다. ID는 기본키입니다.

| NAME    | TYPE    |
| ------- | ------- |
| ID      | INT     |
| NAME    | VARCHAR |
| HOST_ID | INT     |

PLACE_REVIEWS 테이블은 공간을 임대한 사람이 남긴 후기를 담은 테이블입니다. PLACE_REVIEWS 테이블의 구조는 다음과 같으며 ID, PLACE_ID, CREATED_AT, REVIEWER_ID, COMMENTS 는 각각 아이디, 공간의 아이디, 후기를 남긴 날짜, 후기를 남긴 유저의 아이디, 내용을 나타냅니다. ID는 기본키입니다.

| NAME        | TYPE    |
| ----------- | ------- |
| ID          | INT     |
| PLACE ID    | INT     |
| CREATED_AT  | DATE    |
| REVIEWER ID | INT     |
| COMMENTS    | VARCHAR |
### 문제
임대 서비스에서는 후기가 하나도 안 달린 공간, 50개 미만인 공간, 100개 미만인 공간, 100개 이상인 공간은 각각 몇 개인지 구하려 합니다. 후기 수 별로 공간이 몇 개인지 조회하는 SQL문을 작성해주세요. 이때 후기가 하나도 안 달린 공간은 0 , 50개 미만인 공간은 < 50 , 100개 미만인 공간은 < 100 , 100개 이상인 공간은 >= 100 으로 표시 해야 합니다. 또한 결과는 후기수가 작은 순서대로 보여주세요. 자세한 포맷은 하단의 예제를 참고해주세요.
### 예시
예를 들어, PLACES 테이블이 다음과 같고

PLACES

| ID       | NAME                                             | HOST_ID   |
| -------- | ------------------------------------------------ | --------- |
| 1001457  | Docklands Apartment with River Views             | 5507453   |
| 5194998  | BOUTIQUE STAYS - Elwood Beaches 3, Pet Friendly  | 760849    |
| 11762465 | Fabulous single room                             | 20584468  |
| 13627321 | Sunny, Modern Apartment with Cityscape Views     | 10810140  |
| 17810814 | Stylish Bayside Retreat with a Luscious Garden   | 760849    |
| 22002927 | Junction of CBD,Casino&Yarra River* FREE PARKING | 133472555 |
PLACE_REVIEWS

테이블의 레코드에
• 1001457번 공간에는 후기가 73개
• 11762465번 공간에는 후기가 0개
• 5194998번 공간에는 후기가 2개
• 17810814번 공간에는 후기가 5개
• 22002927번 공간에는 후기가 51개
• 13627321번 공간에는 후기가 200개
라면 SQL 문을 실행한 결과는 다음과 같이 나와야 합니다.

| 후기 수   | 공간 수 |
| ------ | ---- |
| 0      | 1    |
| < 50   | 2    |
| < 100  | 2    |
| >= 100 | 1    |

※ 50 , < 100

등을 표시할 때에는 띄어쓰기에 주의하세요.

### 제출
```sql
SELECT
	후기구분 AS '후기 수',
	COUNT(*) AS '공간 수'
FROM (
	SELECT
		p.ID AS 공간_ID,
		CASE
			WHEN COUNT(pr.ID) = 0 THEN '0'
			WHEN COUNT(pr.ID) < 50 THEN '< 50'
			WHEN COUNT(pr.ID) < 100 THEN '< 100'
			ELSE '>= 100'
		END AS 후기구분
	FROM
		PLACES p
		LEFT JOIN
		PLACE_REVIEWS pr ON p.ID = pr.PLACE_ID
	GROUP BY
		p.ID
) subquery
GROUP BY
	후기구분
ORDER BY
	FIELD(후기구분, '0', '< 50', '< 100', '>= 100');
```