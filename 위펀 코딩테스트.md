## 1번 문제
### 문제 설명
매달 k 일은 아파트 관리비를 내는 날입니다. 만약 그달의 K 일이 주말(토요일, 일요일)이라면 관 리비는 k 일로부터 가장 가까운 평일에 냅니다. 한 해의 시작일인 1월 1일에 해당하는 요일 day 와 매달 관리비를 내야 하는 날짜 k가 매개변수로 주어질 때, 그해의 1월부터 12월까지 매달 k 일이 평일이면 0을, 주말이면 1을 순서대로 배열에 담아 return 하도록 Solution 함수를 완성해 주세요.
### 제한사항
- ﻿﻿1월 1일에 해당하는 요일은 다음과 같이 숫자로 주어집니다.
- ﻿﻿월요일: 0, 화요일: 1, 수요일: 2, 목요일: 3, 금요일: 4, 토요일: 5, 일요일: 6
- ﻿k는 1 이상 28 이하의 자연수입니다.
- ﻿﻿각 달의 날짜 수는 1월부터 순서대로 [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31] 이 며, 윤년과 공휴일은 고려하지 않습니다.
### 입출력 예

| day | k   | result                   |
| --- | --- | ------------------------ |
| 6   | 1   | [1,0,0,1,0,0,1,0,0,1,0,0 |
| 6   | 25  | [0,11,0,0,1,0,0,0,0,1,0] |

#### 입출력 예 #1
이 예시에서 1월 1일은 일요일이고, 매달 1일에 관리비를 내야 합니다. 1월 1일은 주말이므로 result 배열의 첫 번째 원소는 1입니다. 2월부터 12월까지 매달 1일에 해당하는 요일은 다음과 같습니다.
- ﻿﻿2월: 수요일
- ﻿﻿3월: 수요일
- ﻿﻿4월: 토요일
- ﻿﻿5월: 월요일
- ﻿﻿6월: 목요일
- ﻿﻿7월: 토요일
- ﻿﻿8월: 화요일
- ﻿﻿9월: 금요일
- ﻿﻿10월: 일요일
- ﻿﻿11월: 수요일
- ﻿﻿12월: 금요일
따라서 1월부터 순서대로 [1,0,0,1,0,0,1,0,0,1,0,0]을 return 하면 됩니다.
#### 입출력 예 #2
이 예시에서 1월 1일은 일요일이고, 매달 25일에 관리비를 내야 합니다. 1월 25일은 수요일이므 로 result 배열의 첫 번째 원소는 0입니다. 마찬가지로 2월~12월까지 매달 25일에 해당하는 요 일은 2월부터 순서대로 토요일, 토요일, 화요일, 목요일, 일요일, 화요일, 금요일, 월요일, 수요 일, 토요일, 월요일입니다. 따라서 1월부터 순서대로 [0,1,1,0,0,1,0,0,0,0,1,0]을 return 하면 됩 니다.
### 제출
```java
class Solution {
	public int[] solution(int day, int k) {
		int[] daysInMonth = {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};
		int[] result = new int[12];

		for (int i = 0; i < 12; i++) {
			int dayOfMonth = (day + (k - 1)) % 7;
			
			if (dayOfMonth == 5 || dayOfMonth == 6) {
				result[i] = 1;
			} else {
				result[i] = 0;
			}
			day = (day + daysInMonth[i]) % 7;
		} 
		return result;
	}
}
```
## 2번 문제
### 문제 설명
유저가 주문한 음식 데이터를 이용해 음식을 가장 다양하게 주문한 유저는 누구인지 알아보려 합니다. 유저는 주문 한 번당 음식 여러 종류를 주문하며, 같은 음식을 여러 번 주문할 수도 있습 니다.

예를 들어 음식 주문 데이터가 다음과 같은 경우
["alex pizza pasta", "alex pizza pizza", "alex noodle", "bob pasta", "bob noodle sandwich pasta", "bob steak noodle"]
- ﻿"alex"는 "pizza", "pasta", "noodle"을 주문했습니다.
- ﻿﻿"b0b"은 "pasta", "noodle", "sandwich", steak"를 주문했습니다.
따라서 "bob"이 주문한 음식이 총 네 종류로 가장 많습니다.

유저 ID와 각 유저가 주문한 음식이 문자열 형태로 들어있는 배열 orders가 매개변수로 주어질 때, 가장 많은 종류의 음식을 주문한 유저의 아이디를 배열에 담아 return 하도록 solution 함수 를 완성해주세요. 만약, 그런 유저가 여러 명이면 해당 유저들을 오름차순으로 정렬해 return 하 면 됩니다.
### 제한사항
- ﻿﻿1 <= orders의 길이 <= 200,000
- ﻿﻿orders의 원소는 음식 주문 데이터가 "유제ID 음식1 음식2 .." 순서로 들어있습니다.
- ﻿﻿유저는 한 번에 최대 5개까지 음식을 주문합니다.
- ﻿﻿유저 ID와 음식 이름은 공백(스페이스 바) 하나로 구분해서 주어집니다.
- ﻿﻿음식과 음식도 공백(스페이스 바) 하나로 구분해서 주어집니다.
- ﻿﻿유저 ID와 음식 이름은 길이가 1 이상 10 이하인 문자열이며, 알파벳 소문자로만 이 루어져 있습니다.
### 입출력 예
| orders                                                                                                                       | result   |
| ---------------------------------------------------------------------------------------------------------------------------- | -------- |
| ["alex pizza pasta", "alex pizza pizza", "alex noodle", "bob pasta",<br><br>"bob noodle sandwich pasta", "bob steak noodle"] | ["bob"]  |
| ["alex pizza pasta steak", "bob noodle sandwich pasta", "choi pizza                                                          | ["alex", |
| sandwich pizza", "alex pizza pasta steak"]                                                                                   | "bob"]   |

#### 입출력 예 #1
문제 예시와 같습니다.
#### 입출력 예#2
"alex"와 "bob"은 음식 세 종류를 주문했으며, "choi"는 두 종류를 주문했습니다. 따라서 오름 차순 정렬하여 ["alex", "bob"]을 retum하면 됩니다.
### 제출
```java
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

class Solution {
	public String[] solution(String[] orders) {
		Map<String, Set<String>> userFoodMap = new HashMap<>();
  
		for (String order : orders) {
			String[] parts = order.split(" ");
			String userId = parts[0];
			
			userFoodMap.putIfAbsent(userId, new HashSet<>());

			for (int i = 1; i < parts.length; i++) {
				userFoodMap.get(userId).add(parts[i]);
			}
		}  
		int maxVariety = 0;
		
		for (Set<String> foods : userFoodMap.values()) {
			maxVariety = Math.max(maxVariety, foods.size());
		}

		List<String> result = new ArrayList<>();
		for (Map.Entry<String, Set<String>> entry : userFoodMap.entrySet()) {
			if (entry.getValue().size() == maxVariety) {
				result.add(entry.getKey());
			}
		}

		Collections.sort(result);

return result.toArray(new String[0]);

}

}
```