---
layout: default
title: 엔디안(Endian)
parent: Computer Science
nav_order: 2
---

# 엔디안(Endian)

컴퓨터의 메모리와 같은 1차원의 공간에 여러 개의 연속된 대상을 배열하는 방법을 뜻하며, 바이트를 배열하는 방법을 특히 바이트 순서(Byte order)라 한다.

빅 엔디안, 리틀 엔디안이 주로 사용되고 바이 엔디언, 미들 엔디언과 같은 방식들도 존재한다.

## 이름의 유래

<img src="/assets/images/img/%08computer-science/eggs.png" width="400">

걸리버 여행기에서 달걀을 깰 때 뭉툭한 끝(big end)을 먼저 깨는 사람들(빅 엔디안)과 뾰족한 끝(little end)을 먼저 깨는 사람들(리틀 엔디안) 사이에 격론이 벌어진 데서 유래했다.

## 빅 엔디안(Big Endian)

사람이 숫자를 읽고 쓰는 방법과 같기 때문에 디버깅 과정에서 메모리의 값을 보기 편해서 디버깅을 편하게 해주는 경향이 있다.

예를 들어 사람은 321이란 숫자를 읽기 위해 왼쪽(숫자가 큰 쪽)부터 읽는다. 똑같이 바이트도 32비트 숫자인 `0x59654148`은 빅 엔디안으로 `59 65 41 48`로 배열된다.

네트워크 상에서 데이터를 전송할 때는 빅 엔디안 방식을 사용한다.

## 리틀 엔디안(Little Endian)

빅 엔디안과는 반대로 작은 숫자가 앞으로 오는 방식이다. 예를 들어 321이란 숫자를 표현할 때 123으로 표현한다고 생각하면 된다. 똑같이 바이트도 32비트 숫자인 `0x59654148`은 `48 41 65 59`로 배열된다.

x86 프로세서들은 리틀 엔디안 방식을 사용하고, Arm 프로세서들은 성능 향상을 위해 빅 엔디안, 리틀 엔디안 두 방법 중 하나를 선택할 수 있도록 되어 있다.

## 각 방식의 장단점

### 계산에서

리틀 엔디안 방식은 메모리에 저장된 값의 하위 비트들만 사용할 때 별도 계산이 필요 없다는 장점이 있다. 32비트 숫자인 0x2A는 리틀 엔디안으로 표현하면 `2A 00 00 00`이 되는데 이 때 앞의 두 바이트 또는 한 바이트만 떼어 내면 하위 16비트 또는 8비트를 바로 얻을 수 있는 장점이 있다. 

반면 빅 엔디안 방식에서는 하위 16비트나 8비트 값을 얻기 위해서는 변수 주소에 2바이트&3바이트를 더해야 한다.

### 개발 측면에서

보통 변수의 첫 바이트를 해당 변수의 주소로 삼기 때문에 프로그래밍을 편하게 하는 반면(첫 바이트부터 뒤로 읽어가면 되기 때문), 리틀 엔디안 방식은 개발자가 빅 엔디안 환경에서 종종 실수를 일으키는 이유를 제공하기도 한다.

### 가산기

가산기가 덧셈을 하는 과정은 LSB(최하위 비트)로부터 시작하여 자리 올림을 계산해야 하므로, 첫 번째 바이트가 LSB인 리틀 엔디안에서는 가산기 설계가 조금 더 단순해진다(앞에서 뒤로 바이트를 읽어가면 되기 때문). 빅 엔디안에서는 가산기가 덧셈을 할 때 마지막 바이트로부터 시작하여 첫 번째 바이트까지 역방향으로 진행해야 한다. 

그러나 오늘날의 프로세서는 여러개의 바이트를 동시에 읽어들여 동시에 덧셈을 수행하는 구조를 갖고 있어 두 엔디안 방식 사이에 사실상 차이가 없다고 한다.

## 참고

[위키피디아](https://ko.wikipedia.org/wiki/%EC%97%94%EB%94%94%EC%96%B8)