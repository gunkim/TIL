# 구조적 프로그래밍

## 증명
다익스트라가 초기에 인식한 문제는 다음과 같다.
- 프로그래밍은 어렵다.
- 프로그래머는 프로그래밍을 잘하지 못한다.

다익스트라는 증명(proof)이라는 수학적인 원리로 이 문제를 해결하고자 했다. 그는 수학자가 사용하는 **유클리드 계층구조**를 프로그래머도 사용할 수 있다고 믿었다. 이를 연구하다 두 가지 경우와 사실을 발견했다.
- **`goto`문장이 모듈을 더 작은 단위로 재귀적으로 분해하는 과정에 방해가 되는 경우.** 만약 모듈을 분리할 수 없다면, 합리적으로 증명할 때 필수적인 기법인 분할 정복 접근법을 사용할 수 없게 된다.
- **`goto`문장을 사용하더라도 모듈을 분해할 때 문제가 되지 않는 경우.** 이런 *좋은* 사용 방식은 `if/then/else`와 `do/while`와 같은 분기와 반복이라는 단순한 제어 구조에 해당한다는 사실이었다.

위 사실을 토대로 모든 프로그램은 `순차, 분기, 반복`이라는 3가지 구조만으로 표현이 가능하다는 것을 증명했다. 구조적 프로그래밍은 이렇게 탄생했다.

순차는 열거법을 통해, 분기는 열거법을 재적용하고, 반복은 귀납법을 통해 고되고 복잡했지만 증명은 해냄으로써 프로그램에서도 정리에 대한 **유클리드 계층구조**를 만들 수 있을 거라는 생각이 실제로 이루어지는 듯 했다.

## 해로운 성명서
1968년 다익스트라는 CACM 편집자에게 `goto문의 해로움`이라는 제목으로 보낸 편지는 3월호에 실리게 되었다. 그 후 여러 논쟁으로 인한 전쟁이 발발되어 10년 이상 지속된 끝에 다익스트라는 마침내 승리하였다.

컴퓨터 언어가 진화하면서 `goto`문장은 계속 뒤편으로 밀려났고, 마침내 거의 사라졌다. 대다수의 현대적 언어는 `goto`문장을 포함하지 않는다.

## 기능적 분해
구조적 프로그래밍을 통해 모듈을 기능적으로 분해할 수 있게 되면서 이를 토대로 구조적 분석이나 구조적 설계와 같은 기법이 인기를 끌었다.

프로그래머는 대규모 시스템을 모듈과 컴포넌트로 나눌 수 있고, 더 나아가 모듈과 컴포넌트는 입증할 수 있는 아주 작은 기능들로 세분화할 수 있게 되었다.

## 엄밀한 증명은 없었다
많은 프로그래머들은 세세한 기능 하나하나를 엄밀히 증명하는 고된 작업이 득이 된다고 생각하지 않았고, 결국 프로그램 관점에서 정리에 대한 유클리드 계층 구조는 **끝내 만들어지지 않았다.**

하지만 올바름을 입증할 때 유클리드 방식과 같은 수학적인 증명만이 있는 것은 아니다. 상당히 성공한 또 다른 전략으로 **과학적인 방법**이 있다.

## 과학이 구출하다
과학은 수학과 달리 올바름을 절대 증명할 수 없지만, 반증은 가능하다.

수학은 증명 가능한 서술이 진실임을 입증하는 것이고, 과학은 증명 가능한 서술이 거짓임을 입증하는 원리라고 볼 수 있다.

> 예를 들어 수학은 A 기능은 아예 버그가 없어!를 해야 하는거고, 과학은 A 기능이 버그가 아예 없을 지는 잘 모르겠지만 최소한 ~~에 대한 버그는 없다는 것은 ~~를 통해 증명할 수 있어. 라고 볼 수 있다.

## 테스트
다익스트라는 **테스트는 버그가 있음을 보여줄 뿐, 버그가 없음을 보여줄 수는 없다**고 한 적이 있다. 다시 말해 프로그램이 잘못되었음을 테스트를 통해 증명할 수 있지만, 프로그램이 맞다고 증명할 수는 없다.

이처럼 프로그래밍은 수학적인 구조를 다루는 듯 보여도 실제로는 과학과도 같다. 최선을 다하더라도 올바르지 않음을 증명하는 데 실패함으로써 올바름을 보여주기 때문이다.

## 결론
구조적 프로그래밍이 오늘날까지 가치 있는 이유는 프로그래밍에서 반증 가능한 단위를 만들어 내는 능력 때문이다.

이는 현대적 언어가 goto 문장은 지원하지 않는 이유이기도 하며 아키텍처 관점에서는 기능적 분해를 최고의 실천법 중 하나로 여기는 이유이기도 하다.